#
# @(#)compiler.properties	1.16 03/06/09
#
#  Copyright 1999-2001 by Sun Microsystems, Inc.,
# 901 San Antonio Road, Palo Alto, California, 94303, U.S.A.
# All rights reserved.
#
# This software is the confidential and proprietary information
# of Sun Microsystems, Inc. ("Confidential Information").  You
# shall not disclose such Confidential Information and shall use
# it only in accordance with the terms of the license agreement
# you entered into with Sun.
#

##
## errors
##

compiler.err.abstract.cant.be.instantiated=\
    {0} is abstract; cannot be instantiated
compiler.err.abstract.meth.cant.have.body=\
    abstract methods cannot have a body
compiler.err.already.defined=\
    {0} is already defined in {1}
compiler.err.anon.class.impl.intf.no.args=\
    anonymous class implements interface; cannot have arguments
compiler.err.anon.class.impl.intf.no.qual.for.new=\
    anonymous class implements interface; cannot have qualifier for new
compiler.err.array.req.but.found=\
    array required, but {0} found

compiler.err.break.outside.switch.loop=\
    break outside switch or loop

compiler.err.call.must.be.first.stmt.in.ctor=\
    call to {0} must be first statement in constructor
compiler.err.cant.access=\
    cannot access {0}; {1}
compiler.err.cant.apply.symbol=\
    {0} in {1} cannot be applied to ({2})
compiler.err.cant.assign.val.to.final.var=\
    cannot assign a value to final variable {0}
compiler.err.cant.deref=\
    {0} cannot be dereferenced
compiler.err.cant.inherit.from.final=\
    cannot inherit from final {0}
compiler.err.cant.ref.before.ctor.called=\
    cannot reference {0} before supertype constructor has been called
compiler.err.cant.ret.val.from.meth.decl.void=\
    cannot return a value from method whose result type is void
compiler.err.cant.select.static.class.from.param.type=\
    cannot select a static class from a parameterized type
compiler.err.cant.inherit.diff.arg=\
    {0} cannot be inherited with different arguments: <{1}> and <{2}>
compiler.err.catch.without.try=\
    ''catch'' without ''try''
compiler.err.clash.with.pkg.of.same.name=\
    {0} clashes with package of same name
compiler.err.const.expr.req=\
    constant expression required
compiler.err.cont.outside.loop=\
    continue outside of loop
compiler.err.cyclic.inheritance=\
    cyclic inheritance involving {0}

compiler.err.doesnt.exist=\
    package {0} does not exist
compiler.err.duplicate.class=\
    duplicate class: {0}
compiler.err.duplicate.case.label=\
    duplicate case label
compiler.err.duplicate.default.label=\
    duplicate default label
compiler.err.else.without.if=\
    ''else'' without ''if''
compiler.err.empty.char.lit=\
    empty character literal
compiler.err.except.already.caught=\
    exception {0} has already been caught
compiler.err.except.never.thrown.in.try=\
    exception {0} is never thrown in body of corresponding try statement

compiler.err.finally.without.try=\
    ''finally'' without ''try''
compiler.err.fp.number.too.large=\
    floating point number too large
compiler.err.fp.number.too.small=\
    floating point number too small

compiler.err.icls.cant.have.static.decl=\
    inner classes cannot have static declarations
compiler.err.illegal.char=\
    illegal character: \\{0}
compiler.err.illegal.combination.of.modifiers=\
    illegal combination of modifiers: {0} and {1}
compiler.err.illegal.esc.char=\
    illegal escape character
compiler.err.illegal.forward.ref=\
    illegal forward reference
compiler.err.illegal.initializer.for.type=\
    illegal initializer for {0}
compiler.err.illegal.line.end.in.char.lit=\
    illegal line end in character literal
compiler.err.illegal.qual.not.icls=\
    illegal qualifier; {0} is not an inner class
compiler.err.illegal.start.of.expr=\
    illegal start of expression
compiler.err.illegal.start.of.type=\
    illegal start of type
compiler.err.illegal.unicode.esc=\
    illegal unicode escape
compiler.err.improperly.formed.type.param.missing=\
    improperly formed type, some parameters are missing
compiler.err.incomparable.types=\
    incomparable types: {0} and {1}
compiler.err.int.number.too.large=\
    integer number too large: {0}
compiler.err.internal.error.cant.instantiate=\
    internal error; cannot instantiate {0} at {1} to ({2})
compiler.err.intf.incompatible.diff.ret=\
    interfaces {0} and {1} are incompatible; both define {2}, but with different return type
compiler.err.intf.expected.here=\
    interface expected here
compiler.err.intf.meth.cant.have.body=\
    interface methods cannot have body
compiler.err.invalid.hex.number=\
    hexadecimal numbers must contain at least one hexadecimal digit
compiler.err.invalid.meth.decl.ret.type.req=\
    invalid method declaration; return type required

compiler.err.label.already.in.use=\
    label {0} already in use
compiler.err.local.var.accessed.from.icls.needs.final=\
    local variable {0} is accessed from within inner class; needs to be declared final

#
# limits.  We don't give the limits in the diagnostic because we expect
# them to change, yet we want to use the same diagnostic.  These are all
# detected during code generation.
#
compiler.err.limit.code=\
    code too large
compiler.err.limit.code.too.large.for.try.stmt=\
    code too large for try statement
compiler.err.limit.dimensions=\
    array type has too many dimensions
compiler.err.limit.locals=\
    too many local variables
compiler.err.limit.parameters=\
    too many parameters
compiler.err.limit.pool=\
    too many constants
compiler.err.limit.pool.in.class=\
    too many constants in class {0}
compiler.err.limit.stack=\
    code requires too much stack
compiler.err.limit.string=\
    constant string too long
compiler.err.limit.string.overflow=\
    UTF8 representation for string \"{0}...\" is too long for the constant pool

compiler.err.malformed.fp.lit=\
    malformed floating point literal
compiler.err.missing.meth.body.or.decl.abstract=\
    missing method body, or declare abstract
compiler.err.missing.ret.stmt=\
    missing return statement
compiler.err.missing.ret.val=\
    missing return value
compiler.err.mod.not.allowed.here=\
    modifier {0} not allowed here

compiler.err.name.clash.same.erasure=\
    name clash: {0} and {1} have the same erasure
compiler.err.name.clash.same.erasure.no.override=\
    name clash: {0} in {1} and {2} in {3} have the same erasure, yet none overrides the other
compiler.err.name.reserved.for.internal.use=\
    {0} is reserved for internal use
compiler.err.native.meth.cant.have.body=\
    native methods cannot have a body
compiler.err.no.encl.instance.of.type.in.scope=\
    no enclosing instance of type {0} is in scope
compiler.err.no.intf.expected.here=\
    no interface expected here
compiler.err.no.match.entry=\
    {0} has no match in entry in {1}; required {2}
compiler.err.not.def.public.class.intf.cant.access=\
    {0} in {1} is not defined in a public class or interface; cannot be accessed from outside package
compiler.err.not.def.public.cant.access=\
    {0} is not public in {1}; cannot be accessed from outside package
compiler.err.not.loop.label=\
    not a loop label: {0}
compiler.err.not.stmt=\
    not a statement
compiler.err.not.encl.class=\
    not an enclosing class: {0}

compiler.err.operator.cant.be.applied=\
    operator {0} cannot be applied to {1}

compiler.err.pkg.clashes.with.class.of.same.name=\
    package {0} clashes with class of same name
compiler.err.possible.fall-through.into.case=\
    possible fall-through into case

compiler.err.error.reading.file=\
    error reading {0}; {1}
compiler.err.recursive.ctor.invocation=\
    recursive constructor invocation
compiler.err.ref.ambiguous=\
    reference to {0} is ambiguous, both {1} {2} in {3} and {4} {5} in {6} match
compiler.err.repeated.interface=\
    repeated interface
compiler.err.repeated.modifier=\
    repeated modifier
compiler.err.report.access=\
    {0} has {1} access in {2}
compiler.err.ret.outside.meth=\
    return outside method

compiler.err.signature.doesnt.match.supertype=\
    signature does not match {0}; incompatible supertype
compiler.err.signature.doesnt.match.intf=\
    signature does not match {0}; incompatible interfaces
compiler.err.should.be.abstract.doesnt.def=\
    {0} should be declared abstract; it does not define {1} in {2}
compiler.err.source.cant.overwrite.input.file=\
    error writing source; cannot overwrite input file {0}

compiler.err.try.without.catch.or.finally=\
    ''try'' without ''catch'' or ''finally''
compiler.err.type.doesnt.take.params=\
    type {0} does not take parameters
compiler.err.type.var.cant.be.deref=\
    type variables cannot be dereferenced
compiler.err.type.var.more.than.once=\
    type variable {0} occurs more than once in result type of {1}; cannot be left uninstantiated
compiler.err.type.var.more.than.once.in.result=\
    type variable {0} occurs more than once in type of {1}; cannot be left uninstantiated

compiler.err.unclosed.char.lit=\
    unclosed character literal
compiler.err.unclosed.comment=\
    unclosed comment
compiler.err.unclosed.str.lit=\
    unclosed string literal
compiler.err.undef.label=\
    undefined label: {0}
compiler.err.unreachable.stmt=\
    unreachable statement
compiler.err.initializer.must.be.able.to.complete.normally=\
    initializer must be able to complete normally
compiler.err.unreported.exception.need.to.catch.or.throw=\
    unreported exception {0}; must be caught or declared to be thrown
compiler.err.void.not.allowed.here=\
    ''void'' type not allowed here

compiler.err.wrong.number.type.args=\
    wrong number of type arguments; required {0}

compiler.err.var.might.already.be.assigned=\
    variable {0} might already have been assigned to
compiler.err.var.might.not.have.been.initialized=\
    variable {0} might not have been initialized
compiler.err.var.might.be.assigned.in.loop=\
    variable {0} might be assigned in loop

# In the following string, {1} will always be the detail message from
# java.io.IOException.
compiler.err.class.cant.write=\
    error while writing {0}: {1}

# In the following string, {0} is the name of the class in the Java source.
# It really should be used two times..
compiler.err.class.public.should.be.in.file=\
    class {0} is public, should be declared in a file named {0}.java

## All errors which do not refer to a particular line in the source code are
## preceded by this string.
compiler.err.error=\
    error:\u0020

# The following error messages do not refer to a line in the source code.
compiler.err.cant.read.file=\
    cannot read: {0}

#####

# Fatal Errors

compiler.misc.fatal.err.no.java.lang=\
    Fatal Error: Unable to locate package java.lang in classpath or bootclasspath
compiler.misc.fatal.err.cant.locate.meth=\
    Fatal Error: Unable to locate method {0}

#####

##
## miscellaneous strings
##

compiler.misc.source.unavailable=\
    (source unavailable)
compiler.misc.too.many.constants=\
    too many constants

#####

## The following string will appear before all messages keyed as:
## "compiler.note".
compiler.note.note=\
    Note:\u0020

compiler.note.deprecated.filename=\
    {0} uses or overrides a deprecated API.
compiler.note.deprecated.plural=\
    Some input files use or override a deprecated API.
# The following string will always appear after one of the above deprecation
# messages.
compiler.note.deprecated.recompile=\
    Recompile with -deprecation for details.

compiler.note.unchecked.filename=\
    {0} uses unchecked operations.
compiler.note.unchecked.plural=\
    Some input files use unchecked operations.
# The following string will always appear after one of the above deprecation
# messages.
compiler.note.unchecked.recompile=\
    Recompile with -warnunchecked for details.

#####

compiler.misc.count.error=\
    {0} error
compiler.misc.count.error.plural=\
    {0} errors
compiler.misc.count.warn=\
    {0} warning
compiler.misc.count.warn.plural=\
    {0} warnings

## extra output when using -verbose (JavaCompiler)

compiler.misc.verbose.checking.attribution=\
    [checking {0}]
compiler.misc.verbose.parsing.done=\
    [parsing completed {0}ms]
compiler.misc.verbose.parsing.started=\
    [parsing started {0}]
compiler.misc.verbose.total=\
    [total {0}ms]
compiler.misc.verbose.wrote.file=\
    [wrote {0}]

## extra output when using -verbose (Retro)
compiler.misc.verbose.retro=\
    [retrofitting {0}]
compiler.misc.verbose.retro.with=\
    \tretrofitting {0} with {1}
compiler.misc.verbose.retro.with.list=\
    \tretrofitting {0} with type parameters {1}, supertype {2}, interfaces {3}

## extra output when using -verbose (code/ClassReader)
compiler.misc.verbose.loading=\
    [loading {0}]

## extra output when using -checkclassfile (code/ClassReader)
compiler.misc.ccf.found.later.version=\
    class file has later version than expected: {0}
compiler.misc.ccf.unrecognized.attribute=\
    unrecognized attribute: {0}

## extra output when using -prompt (util/Log)
compiler.misc.resume.abort=\
    R)esume, A)bort>

#####

##
## warnings
##

## All warning messages are preceded by the following string.
compiler.warn.warning=\
    warning:\u0020

compiler.warn.has.been.deprecated=\
    {0} in {1} has been deprecated

compiler.warn.unchecked.assign=\
    unchecked assignment: {0} to {1}
compiler.warn.unchecked.assign.to.var=\
    unchecked assignment to variable {0} of raw type class {1}
compiler.warn.unchecked.call.mbr.of.raw.type=\
    unchecked call to {0} as a member of the raw type {1}
compiler.warn.unchecked.cast.to.type=\
    unchecked cast to type {0}
compiler.warn.unchecked.generic.array.creation=\
    unchecked generic array creation
compiler.warn.unchecked.meth.invocation.applied=\
    unchecked method invocation: {0} in {1} is applied to ({2})

#####

## The following are tokens which are non-terminals in the language. They should
## be named as JLS3 calls them when translated to the appropriate language.
compiler.misc.token.identifier=\
    <identifier>
compiler.misc.token.character=\
    <character>
compiler.misc.token.string=\
    <string>
compiler.misc.token.integer=\
    <integer>
compiler.misc.token.long-integer=\
    <long integer>
compiler.misc.token.float=\
    <float>
compiler.misc.token.double=\
    <double>
compiler.misc.token.bad-symbol=\
    <bad symbol>
compiler.misc.token.end-of-input=\
    <end of input>

## The argument to the following string will always be one of the following:
## 1. one of the above non-terminals
## 2. a keyword (JLS1.8)
## 3. a boolean literal (JLS3.10.3)
## 4. the null literal (JLS3.10.7)
## 5. a Java separator (JLS3.11)
## 6. an operator (JLS3.12)
##
## This is the only place these tokens will be used.
compiler.err.expected=\
    {0} expected

## The following are related in form, but do not easily fit the above paradigm.
compiler.err.case.default.or.right-brace.expected=\
   ''case'', ''default'' or ''}'' expected
compiler.err.class.or.intf.expected=\
    ''class'' or ''interface'' expected
compiler.err.dot.class.expected=\
    ''.class'' expected
compiler.err.left-paren.or.left-square-bracket.expected=\
    ''('' or ''['' expected

## The argument to this string will always be either 'case' or 'default'.
compiler.err.orphaned=\
    orphaned {0}

compiler.misc.anonymous.class=\
    <anonymous {0}>

#####

compiler.misc.bad.class.file.header=\
bad class file: {0}\n\
{1}\n\
Please remove or make sure it appears in the correct subdirectory of the classpath.

## The following are all possible strings for the second argument ({1}) of the
## above strings.
compiler.misc.bad.class.signature=\
    bad class signature: {0}
compiler.misc.bad.const.pool.tag=\
    bad constant pool tag: {0}
compiler.misc.bad.const.pool.tag.at=\
    bad constant pool tag: {0} at {1}
compiler.misc.bad.signature=\
    bad signature: {0}
compiler.misc.class.file.wrong.class=\
    class file contains wrong class: {0}
compiler.misc.dot.class.not.found=\
    file {0}.class not found
compiler.misc.file.doesnt.contain.class=\
    file does not contain class {0}
compiler.misc.illegal.start.of.class.file=\
    illegal start of class file
compiler.misc.unable.to.access.file=\
    unable to access file: {0}
compiler.misc.unicode.str.not.supported=\
    unicode string in class file not supported
compiler.misc.undecl.type.var=\
    undeclared type variable: {0}
compiler.misc.wrong.version=\
    class file has wrong version {0}.{1}, should be {2}.{3}

#####

compiler.err.not.within.bounds=\
    type parameter {0} is not within its bound

compiler.err.not.within.bounds.explain=\
    type parameter {0} is not within its bound; {1}

## The following are all possible strings for the second argument ({1}) of the
## above string.

## none yet...

#####

compiler.err.prob.found.req=\
{0}\n\
found   : {1}\n\
required: {2}

## The following are all possible strings for the first argument ({0}) of the
## above string.
compiler.misc.incompatible.types=\
    incompatible types
compiler.misc.inconvertible.types=\
    inconvertible types
compiler.misc.possible.loss.of.precision=\
    possible loss of precision

#####

compiler.err.type.found.req=\
unexpected type\n\
found   : {0}\n\
required: {1}

## The following are all possible strings for the first argument ({0}) of the
## above string.
compiler.misc.type.req.class=\
    class
compiler.misc.type.req.class.array=\
    class or array
compiler.misc.type.req.ref=\
    reference

#####

## The first argument ({0}) is a "kindname".
compiler.err.abstract.cant.be.accessed.directly=\
    abstract {0} {1} cannot be accessed directly

## The third argument ({2}) is a "kindname".
compiler.err.inherit.hides=\
    {0} is inherited from {1} and hides {2} in outer class {3}.  An explicit ''this'' qualifier must be used to select the desired instance.

## The first argument ({0}) is a "kindname".
compiler.err.non-static.cant.be.ref=\
    non-static {0} {1} cannot be referenced from a static context

## Both arguments ({0}, {1}) are "kindname"s.  {0} is a comma-separated list
## of kindnames (the list should be identical to that provided in source.
compiler.err.unexpected.type=\
unexpected type\n\
required: {0}\n\
found   : {1}

## The first argument ({0}) is a "kindname".
compiler.err.cant.resolve=\
cannot resolve symbol\n\
symbol: {0} {1} {2} {3}

## The first argument ({0}) and fifth argument ({4}) are "kindname"s.
compiler.err.cant.resolve.location=\
cannot resolve symbol\n\
symbol  : {0} {1} {2} {3}\n\
location: {4} {5}

## The following are all possible string for "kindname".
## They should be called whatever the JLS calls them after it been translated
## to the appropriate language.
compiler.misc.kindname.class=\
    class
compiler.misc.kindname.constructor=\
    constructor
compiler.misc.kindname.default=\
    identifier({0})
compiler.misc.kindname.interface=\
    interface
compiler.misc.kindname.method=\
    method
compiler.misc.kindname.package=\
    package
compiler.misc.kindname.type.variable=\
    bound of type variable
compiler.misc.kindname.value=\
    value
compiler.misc.kindname.variable=\
    variable

#####

compiler.err.override.static=\
    {0}; {1} and {2} are static
compiler.err.override.meth=\
    {0}; overridden method is {1}

# In the following string {1} is a space separated list of Java Keywords, as
# they would have been declared in the source code
compiler.err.override.weaker.access=\
    {0}; attempting to assign weaker access privileges; was {1}
compiler.err.override.meth.doesnt.throw=\
    {0}; overridden method does not throw {1}

compiler.misc.override.incompatible.ret=\
    {0}; attempting to use incompatible return type

## The following are all possible strings for the first argument ({0}) of the
## above strings.
compiler.misc.cant.override=\
    {0} in {1} cannot override {2} in {3}
compiler.misc.cant.implement=\
    {0} in {1} cannot implement {2} in {3}
compiler.misc.clashes.with=\
    {0} in {1} clashes with {2} in {3}
